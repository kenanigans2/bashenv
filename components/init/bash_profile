#!/usr/bin/env bash
# USER BASH PROFILE (~/.bash_profile)

report_err ()
{
    #
    # $1 (required) should be the message
    # $2 (optional) is an optional additional string
    #
    local errmsg="${FUNCNAME[1]}-ERROR: "
    errmsg+="${1:?}"
    [[ -n "${2:-}" ]] \
        && errmsg+=" -- ${2}"
    echo -e "\\n${errmsg}\\n" >&2
    return
}

{ 
    [[ "${1:-}" == '-v' ]] \
        && echo "USER BASH PROFILE SOURCED (~/.bash_profile)"
}

#-: SET `$bashenv' VARIABLE with path to project directory
{ #-: LOCATION OF BASHENV REPOSITORY ROOT DIRECTORY

    [[ -z "${bashenv:-}" ]] \
        && [[ -d "${HOME}/Developer/bashenv" ]] \
        && declare -xr bashenv="${HOME}/Developer/bashenv"
    [[ -z "${scripts:-}" ]] \
        && [[ -d "${bashenv}/scripts" ]] \
        && declare -xr scripts="${bashenv}/scripts"

    # shellcheck source=/Users/kend/.profile
    [[ -r ~/.profile ]] && . ~/.profile
    # shellcheck source=/Users/kend/.bashrc
    [[ -r ~/.bashrc ]] && . ~/.bashrc
}

{ #-: CONFIGURE HISTORY
    __verify_hist_file_locations ()
    {
        cleanup ()
        {
            if [ -f "${original_path}" ]; then
                if [[ -w "${original_path}" ]]; then
                    rm "${original_path}"
                else
                    echo "ERROR: insufficient permissions to mv less history file at ~/.lesshst" >&2
                    local -l REPLY=
                    read -rp "REMOVE WITH SUDO? (n) " REPLY
                    case "${REPLY:0:1}" in
                        y)
                            echo -n "ENTER YOUR PASSWORD: "
                            [[ -f ~/.lesshst ]] \
                                && sudo rm ~/.lesshst
                            [[ ! -f ~/.lesshst ]] \
                                && echo "SUCCESS"\!
                            return
                            ;;

                        *)
                            echo "Aborting... LESSHISTFILE will remain: ~/.lesshst"
                            return
                            ;;
                    esac
                fi
            fi
            return
        }

        local varname original_path new_path
        varname="${1:?}" original_path="${2:?}" new_path="${3:?}"

        [[ ! -f "${new_path:-}" ]] \
            && touch "${new_path}"

        [[ -z "${!varname:-}" ]] \
            && eval "export \"${varname}\"=\"${new_path}\""

        if [[ -f "${original_path}" ]]; then
            trap 'cleanup' RETURN HUP
            [ -s "${original_path}" ] \
                && cat "${original_path}" >> "${new_path}"
        fi
        return
    }

    [[ ! -d ~/.history ]] \
        && mkdir ~/.history

    if [[ -f ~/.bash_history && -w ~/.bash_history ]]; then
        cat ~/.bash_history >> ~/.history/bash_history
        rm ~/.bash_history
    fi

    export HISTSIZE=10000
    export HISTFILESIZE=10000
    export HISTCONTROL=ignoreboth
    export HISTIGNORE=c:h:j:x:clear:history:jobs:exit

    __verify_hist_file_locations MYSQL_HISTFILE ~/.{,history/}mysql_history
    __verify_hist_file_locations LESSHISTFILE ~/.lesshst ~/.history/less_history
    __verify_hist_file_locations MYCLI_HISTFILE ~/.mycli-history ~/.history/mycli_history
    __verify_hist_file_locations PYTHON_HISTFILE ~/.python_history ~/.history/python_history
    unset -f __verify_hist_file_locations


    declare iOSConfFile="${bashenv}/components/notthedroids-ixs.bash"
    #shellcheck source=/Users/kend/Developer/bashenv/components/notthedroids-ixs.bash
    if [[ "${TERM_PROGRAM:-}" == 'iOS' ]]; then
        if [[ -f "${iOSConfFile}" ]]; then
            source "${iOSConfFile}"
        else
            echo "ERROR: failed to source iOS config file -- ${iOSConfFile}" >&2
            return 1
        fi

        echo "SUCCESSFULLY SOURCED iOS CONFIG FILE -- ${iOSConfFile}"
        unset iOSConfFile
    fi
}

{ #-: PROMPT - PROMPT_COMMAND
    if ! declare -F ps1_command &> /dev/null; then
        ps1_command ()
        {
            local -ir xit=$?
            if ((xit != 0)); then
                echo -e "\\n\\t[[31;1m${xit}[0;0m]\\n"
            else
                echo
            fi
            return ${xit}
        }
    fi

    if ! echo "${PROMPT_COMMAND:-}" | grep -q 'ps1_command'; then
        export PROMPT_COMMAND="ps1_command${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
    fi

}

{ #-: SHELL OPTIONS
    shopt -s cdable_vars extglob globstar
}

#{ #-: LOCATION VARS
#    __verify_location_vars ()
#    {
#        local varname="${1:?}"
#        shift 1
#        targetDir="${*}"
#
#        if [[ -d "${targetDir}" && -x "${targetDir}" ]]; then
#            #
#            echo
#        else
#            #
#            # DIR NOT VERIFIED
#            report_err "ERROR: unable to set location variable for \`${varname}' -- ${targetDir}"
#            return 1
#        fi
#        return
#    }
#
#    __verify_location_vars dev ~/Developer
#    unset -f __verify_location_vars
#}

#-: OTHER ENV VARS
{
    if [[ -f ~/mbox ]]; then
        /bin/ls -ldO ~/mbox \
            | grep -q hidden \
    else
        chflags hidden ~/mbox
    fi

    if ! echo "${PATH}" | grep -q "${HOME}/bin"; then
        [[ ! -d ~/bin ]] && mkdir ~/bin
        PATH="${HOME}/bin${PATH:+:$PATH}"
    fi

    if ! echo "${PATH}" | grep -q "/usr/local/sbin"; then
        PATH="/usr/local/sbin${PATH:+:$PATH}"
    fi

    export CDPATH=.:${HOME}
    export GLOBIGNORE=.DS_Store:.CFUserTextEncoding:.localized:.Trash

    declare -xA EMOJIS=( [coffee]=‚òïÔ∏è [apple]=üçé )
}

if [[ -s "${bashenv:?}/.private" ]]; then
    #shellcheck source=/Users/kend/Developer/bashenv/.private
    source "${bashenv}/.private"
fi

#-: BASH COMPLETION (@2)
{ 
    [[ -r "/usr/local/etc/profile.d/bash_completion.sh" ]] \
        && . "/usr/local/etc/profile.d/bash_completion.sh"

    declare -i c=1 errs=0
    declare -a errArr=()
    if [[ -d "/usr/local/etc/bash_completion.d" ]]; then
        while IFS='\n' read -r INPUT; do
            [[ -f "${INPUT}" && -r "${INPUT}" ]] \
                && source "${INPUT}" \
                || ((errs+=1))
        done < <(find /usr/local/etc/bash_completion.d \! -type d)
        
        if (( errs > 0 )); then
            echo "ERROR: errors occurred while loading .../etc/bash_completion.d files" >&2
        fi
    fi
    unset c errs errArr
}

